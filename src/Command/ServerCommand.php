<?php
// +----------------------------------------------------------------------
// | Created by linshan. 版权所有 @
// +----------------------------------------------------------------------
// | Copyright (c) 2020 All rights reserved.
// +----------------------------------------------------------------------
// | Technology changes the world . Accumulation makes people grow .
// +----------------------------------------------------------------------
// | Author: kaka梦很美 <1099013371@qq.com>
// +----------------------------------------------------------------------

namespace Raylin666\Framework\Command;

use Exception;
use Swoole\Server\Port;
use swoole_process;
use Raylin666\Server\ServerManager;
use Raylin666\Server\ServerConfig;
use Raylin666\Utils\Helper\PhpHelper;
use Raylin666\Framework\Contract\ServerStateInterface;
use Raylin666\Server\Contract\ServerManangerInterface;
use Raylin666\Framework\Handler\ServerStateHandler;
use Raylin666\Framework\Helper\SwooleHelper;
use Raylin666\Server\Contract\ServerInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;

/**
 * Class ServerCommand
 * @package Raylin666\Framework\Command
 */
class ServerCommand extends Command
{
    /**
     * @var string
     */
    protected static $name = 'server';

    /**
     * @var string
     */
    protected static $description = '创建 Swoole 服务';

    /**
     * Console configure
     */
    protected function configure()
    {
        parent::configure(); // TODO: Change the autogenerated stub

        $this->container->singleton(ServerStateInterface::class, function () {
            return new ServerStateHandler();
        });

        $this->addArgument('status', InputArgument::OPTIONAL, '服务状态类型 status | start | reload | stop');
        $this->addOption('daemon', 'd', InputOption::VALUE_NONE, '是否守护进程 --daemon | -d');
    }

    /**
     * @param InputInterface  $input
     * @param OutputInterface $output
     * @return int|void
     */
    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $this->input = $input;
        $this->output = $output;
        $state = $this->setServerStatusType($input);
        $this->isDaemon($input);
        $this->$state();
        exit(1);
    }

    /**
     * 获取服务状态类型
     * @param InputInterface $input
     * @return string
     * @throws Exception
     */
    protected function setServerStatusType(InputInterface $input): string
    {
        $status = $input->getArgument('status') ?: ServerStateHandler::SERVER_TYPE_STATUS;
        $this->getServerState()->withServerStatusType($status);
        return $status;
    }

    /**
     * 是否守护进程运行
     * @param InputInterface $input
     * @return bool
     */
    protected function isDaemon(InputInterface $input): bool
    {
        $isDaemon = $input->hasParameterOption(['--daemon', '-d'], true) ? true : false;
        $this->getServerState()->withDaemon($isDaemon);
        return $isDaemon;
    }

    /**
     * 获取服务 PID
     * @return int
     * @throws Exception
     */
    protected function getServerPid(): int
    {
        $pidFile = $this->config->get('server.settings.pid_file');
        return file_exists($pidFile) ? intval(file_get_contents($pidFile)) : 0;
    }

    /**
     * 获取服务状态
     */
    protected function status()
    {
        exec(SwooleHelper::getPsAuxProcessCommand(static::$name), $output);

        // 进程列表
        $rows = SwooleHelper::getAllProcess(static::$name);
        $headers = ['USER', 'PID', 'RSS', 'STAT', 'START', 'COMMAND'];
        foreach ($rows as $key => $value) {
            $rows[$key] = array_combine($headers, $value);
        }

        $this->getio()->table($headers, $rows);

        $pid = $this->getServerPid();
        if (!empty($pid) && swoole_process::kill($pid, SIG_DFL)) {
            $this->getio()->success('服务已处于运行状态');
        } else {
            $this->getio()->warning('服务已处于停止状态');
        }

        unset($headers, $output, $rows);
    }

    /**
     * 启动服务
     */
    protected function start()
    {
        $server = $this->getServer();
        $config = $this->config->get('server');
        // 是否守护进程模式
        $daemonize = $config['settings']['daemonize'] ?? false;
        if (! $daemonize) {
            $config['settings']['daemonize'] = $this->getServerState()->isDaemon();
        }

        // 初始化服务配置
        $server->init(new ServerConfig($config));

        $servNames = array_column($config['servers'], 'name');
        $listenerStrings = '';
        foreach ($servNames as $servName) {
            if ($this->getServerManager()::has($servName)) {
                $servListener = ServerManager::get($servName);
                /** @var Port $servPort */
                $servPort = $servListener[1];
                $listenerStrings .= sprintf(
                    '> %s - %s:%d' . PHP_EOL,
                    $servName,
                    $servPort->host,
                    $servPort->port
                    );
            }
        }

        $messages = [
            ['服务类型', implode(', ', $servNames)],
            ['', ''],
            ['监听信息', $listenerStrings],
            ['服务监控地址', $server->getServer()->host],
            ['服务监听端口', $server->getServer()->port],
            ['服务 PID 文件', $config['settings']['pid_file'] ?? ''],
            ['PHP 运行版本', phpversion()],
            ['Swoole 运行版本', SWOOLE_VERSION],
            ['当前机器所有网络接口的IP地址', SwooleHelper::getLocalIp()],
            ['正在运行的服务用户', get_current_user()],
            ['是否守护进程模式', $this->getServerState()->isDaemon() ? '是' : '否'],
            ['框架运行名称', $this->app->name()],
            ['框架运行版本', $this->app->version()],
        ];

        $headers = ['信息名称', '信息内容'];
        foreach ($messages as $key => $value) {
            $messages[$key] = array_combine($headers, $value);
        }

        $this->getio()->table($headers, $messages);
        $this->getio()->success(
            sprintf(
                '服务已成功启动 - %s:%d, 启动时间 - %s',
                $server->getServer()->host,
                $server->getServer()->port,
                date('Y-m-d H:i:s')
            )
        );

        unset($headers, $rows);

        // 启动服务
        $this->getServer()->start();
    }

    /**
     * 服务平滑重启
     */
    protected function reload()
    {
        PhpHelper::opCacheClear();
        $pid = $this->getServerPid();
        if (! swoole_process::kill($pid, SIG_DFL)) {
            throw new Exception(sprintf('服务 PID : %d 不存在 ', $pid));
        }

        swoole_process::kill($pid, SIGUSR1);

        $this->getio()->success(
            sprintf(
                '服务 PID : %d 正在向所有工作进程发送平滑加载通知服务, 于 %s 完成加载',
                $pid,
                date('Y-m-d H:i:s')
            )
        );
    }

    /**
     * 停止服务
     * @throws Exception
     */
    protected function stop()
    {
        $pid = $this->getServerPid();
        if (empty($pid) || (! swoole_process::kill($pid, SIG_DFL))) {
            return $this->getio()->warning('服务已处于停止状态');
        }

        swoole_process::kill($pid, SIGTERM);

        $time = time();
        while (true) {
            // 延迟执行
            usleep(100000);
            if (swoole_process::kill($pid, SIG_DFL)) {
                swoole_process::kill($pid, SIGTERM);

                if (time() > $time+15) {
                    throw new Exception('服务停止异常 - 请尝试强制停止服务或 KILL 进程');
                }
            } else {
                // 检查进程是否已杀死, 发送停止服务信号
                $this->getio()->success(sprintf('服务已成功停止, 停止时间 - %s', date('Y-m-d H:i:s')));
                break;
            }
        }
    }

    /**
     * @return ServerInterface
     */
    protected function getServer(): ServerInterface
    {
        return $this->container->get(ServerInterface::class);
    }

    /**
     * @return ServerManager|string
     */
    protected function getServerManager()
    {
        return $this->container->get(ServerManangerInterface::class);
    }

    /**
     * @return ServerStateHandler
     */
    protected function getServerState(): ServerStateHandler
    {
        return $this->container->get(ServerStateInterface::class);
    }
}